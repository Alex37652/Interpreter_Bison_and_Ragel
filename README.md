# Interpreter_Bison_and_Ragel

Цель проекта познакомится с двумя популярными утилитами для генерации лексеров и парсеров: `ragel` и `bison`. В качестве упражнения был написан калькулятор, в котором есть переменные и функции. В итоге калькулятор справляется с программами на подобие таких:

```
def fib(x): do
    if x > 2: fib(x-1) + fib(x-2)
    else: 1
    done

i=1
while i < 7: do
    i = i + 1
    print(fib(i))
    done
```

```
def f(x, y): do
    a = 0
    if (x < 2): do
        a = a + 1
        done
    else: do
        if y <= 1 || y > 3: do
            a = a + 2
            done
        done
    if x == y && !(a != 0): do
        a = a + x + y
        done
    a*10 + (x - y)
    done

i = 0
while i < 4: do
    j = 0
    while j < 5: do
        k = f(i, j)
        if k != 0: do
            k = k + 1
            done
        else: do
            k = k - 1
            done
        print(k)
        j = j + 1
        done
    i = i + 1
    done

```

### Lexer

Лексер описан в формате, понимаемом утилитой `ragel`. Задача лексера - вернуть токены. Под токенами понимаются элементы синтаксиса такие как операторы, числа и переменные. Интерфейс связки лексера с парсером подразумевает, что результатом вызова лексера будет токен.
### Parser

Парсер описан в файле `parser.y` и будет сгенерирован в настоящий парсер утилитой `bison`. Парсер по правилам строит синтаксическое дерево.

### AST

В файле `ast.h` описаны типы данных для узлов синтаксического дерева.

### Eval

После того, как у нас есть синтаксическое дерево, мы можем обходом по нему вычислить значение выражения. Рекурсивный обход имеется в файле `eval.cc`. Таким образом калькулятор на самом деле получается интерпретатором.

### Main

Интерфейс к калькулятору описывается в функции main.
